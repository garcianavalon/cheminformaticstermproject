package code;
import java.util.AbstractMap;
import java.util.ArrayList;
import org.openscience.cdk.Atom;
import org.openscience.cdk.AtomContainer;
import org.openscience.cdk.Bond;
import org.openscience.cdk.interfaces.IAtom;
import org.openscience.cdk.interfaces.IAtomContainer;
import org.openscience.cdk.interfaces.IBond;
import org.openscience.cdk.smiles.SmilesGenerator;

/**
 * This class provides methods to generate and retrieve
 * The ECF4-Type fragments of an IAtomContainer
 * @author Trenous, Navalon
 *
 */
public class ECFFragmenter {
	private ArrayList<AbstractMap.SimpleEntry<Integer, Integer>> fragmentCount;
	private ArrayList<IAtomContainer> fragmentList;
	private IAtomContainer atomContainer;
	private IAtom starAtom = new Atom();
	
	/**
	 * constructor
	 */
	public ECFFragmenter() {
		super();
	}

	/**
	 * Generates the fragments for the given parameter.
	 * Subsequent calls to getFragmentsAsContainer() will
	 * return the fragments found in atomContainer
	 * @param atomContainer The IAtomContainer to be fragmented
	 * @throws CloneNotSupportedException 
	 */
	public void generateFragments(IAtomContainer atomContainer) {
		this.atomContainer = atomContainer;
		this.fragmentList = new ArrayList<IAtomContainer>();
		for (IAtom a : atomContainer.atoms()) { // for each atom, generate fragments
			for (int i = 0; i<3 ; i++) {// iterate from one bond to three bond size
				IAtomContainer fragment = new AtomContainer(); 
				ArrayList<IAtom> atomList = new ArrayList<IAtom>();
				atomList.add(a);
				if ((fragment = recursiveFragmenter(atomList, new ArrayList<IBond>(), i)) != null)
					fragmentList.add(fragment); // Only add the fragment if it is distinct
			}
		}
		this.generateFragmentCount();
		
	}

	private IAtomContainer recursiveFragmenter(ArrayList<IAtom> lastLayerAtoms, ArrayList<IBond> lastLayerBonds, int i) {
		ArrayList<IAtom> nextLayerAtoms = new ArrayList<IAtom>();
		ArrayList<IBond> nextLayerBonds = new ArrayList<IBond>();
		for (IAtom lastLayerAtom : lastLayerAtoms) {
			for (IAtom nextLayerAtom : atomContainer.getConnectedAtomsList(lastLayerAtom)) {
				if (!lastLayerAtoms.contains(nextLayerAtom)) {
					if (i != 0) {
						nextLayerAtoms.add(nextLayerAtom);
						nextLayerBonds.add(atomContainer.getBond(lastLayerAtom, nextLayerAtom));
					}
					else {
						nextLayerAtoms.add(starAtom);
						nextLayerBonds.add(new Bond(lastLayerAtom,starAtom));
					}
				} else if (!lastLayerBonds.contains(atomContainer.getBond(lastLayerAtom, nextLayerAtom)))
						nextLayerBonds.add(atomContainer.getBond(lastLayerAtom, nextLayerAtom));
			}
		}
		if (nextLayerAtoms.isEmpty())
			return null;
		lastLayerAtoms.addAll(nextLayerAtoms);
		lastLayerBonds.addAll(nextLayerBonds);
		return  (i == 0) ? createAtomContainer(lastLayerAtoms, lastLayerBonds) : recursiveFragmenter( lastLayerAtoms, lastLayerBonds, i-1 ); 

	}

	/**
	 * Remove duplicates and store the result as a List of Hashcodes paired with their count
	 */
	private void generateFragmentCount() {
		SmilesGenerator sg = new SmilesGenerator();
		this.fragmentCount = new ArrayList<AbstractMap.SimpleEntry<Integer, Integer>>();
		ArrayList<String> smiles = new ArrayList<String>();
		for (IAtomContainer fragment : this.fragmentList) {
			System.out.println(sg.createSMILES(fragment)); // debug
			smiles.add(sg.createSMILES(fragment));	
		}
		while (!smiles.isEmpty()) {
			int count = 1;
			String smile = smiles.remove(0);
			for (int i = 0 ; i < smiles.size(); i++) {
				if (smiles.get(i).equals(smile)) {
					smiles.remove(i);
					count++;
					i--;
				}				
			}
			fragmentCount.add(new AbstractMap.SimpleEntry<Integer, Integer>(new Integer(count), new Integer(smile.hashCode())));
		}
		
	}
	private IAtomContainer createAtomContainer(ArrayList<IAtom> atoms,
			ArrayList<IBond> bonds) {
		IAtomContainer atomContainer = new AtomContainer();
		for (IAtom atom : atoms)
			atomContainer.addAtom(atom);
		for (IBond bond : bonds)
			atomContainer.addBond(bond);
		return atomContainer;
	}

	public String[] getFragments() {
		return null;
	}

	/**
	 * Returns the set of fragments generated by the last call of 
	 * generateFragments(), null if the method hasn't been called yet.
	 * @return The generated Fragments
	 */
	public ArrayList<IAtomContainer> getFragmentsAsContainers() {
		return this.fragmentList;
	}

}
